# Introduction

There are an example of building [grep](https://www.gnu.org/software/grep/) or more suitable [ripgrep](https://github.com/BurntSushi/ripgrep) utilities with Iris.

This example can be executed via the below command:

```shell
cabal exec simple-grep -- -f DIR -s TARGET_WORD
```

And will give the following result output:

```shell
> cabal exec simple-grep -- -f path/iris.cabal -s iris

Starting grepping ðŸ”¥ 

 file name: iris.cabal 
 2:
name:                iris
 7:
    See [README.md](https://github.com/chshersh/iris#iris) for more details.
 8:
homepage:            https://github.com/chshersh/iris
 9:
bug-reports:         https://github.com/chshersh/iris/issues
 26:
  location:            https://github.com/chshersh/iris.git
 79:
  build-depends:       , iris
 119:
  autogen-modules:     Paths_iris
 120:
  other-modules:       Paths_iris
 123:
     , iris
 136:
  autogen-modules:     Paths_iris
 137:
  other-modules:       Paths_iris
 150:
test-suite iris-test
 160:
    Paths_iris
 164:
    , iris
```

So, let's begin!

## Preamble: imports and language extensions

First of all, let's define imports and extensions at the head of the tutorial:

```haskell
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NamedFieldPuns #-}


module Main (main) where

import Prelude hiding (readFile)
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Reader (MonadReader)
import System.FilePath (takeFileName)

import qualified Data.Text.Lazy as T
import qualified Data.Text.Lazy.IO as TIO
import qualified Options.Applicative as Opt

import qualified Colourista
```

So, we're writing a simple grep utility, we need here `Colourista` library for printing colored messages via the Iris app. Other libraries such as `Text` are standard for our specific task. `optparse-applicative` is needed here for defining the set of commands that Iris will consume.

Also, will be great to highlight Iris import's preferences separately. The matter of convention is to keep Iris import qualified, library was designed in that kind of stuff, so we could get functions and types via `Iris.makeSome`:

```haskell
import qualified Iris
import qualified Paths_iris as Autogen
```

Second, we import autogenerated module after building the project with cabal. It is needed below for stubbing the `Iris.cliEnvSettingsVersionSettings` field in our case. It depends on your wishes on how to introduce the application's version, you could just load it from env variables or from whatever else.

## Core data types

After imports, let's define our main monad and derive another helper classes:

```haskell
newtype App a = App
    { unApp :: Iris.CliApp SimpleGrep () a
    } deriving newtype
        ( Functor
        , Applicative
        , Monad
        , MonadIO
        , MonadReader (Iris.CliEnv SimpleGrep ())
        )
```

`Iris.CliApp` here is the main monad of the library. This monad will consume our datatype of commands `SimpleGrep` in his first argument and in the second argument - application env datatype that might be empty depending on your wishes and goals. However, we can get application datatype by using `ask` or `Iris.asksCliEnv` in our `App` monad. Command datatype, after consuming, will be parsed and putted into `--help` list.

Here's our commands for utility:

```haskell
data SimpleGrep = SimpleGrep
    { filePath :: !String
    , substring :: !String
    }
```

And, apart from other settings below, the definition of command parser in the language of `optparse-applicative`:

```haskell
commandsSettings :: Opt.Parser SimpleGrep
commandsSettings = SimpleGrep
        <$> Opt.strOption
            (  Opt.long "filePath"
            <> Opt.short 'f'
            <> Opt.metavar "PATH"
            <> Opt.help "filePath to find and grep file"
            )
        <*> Opt.strOption
            (  Opt.long "substring"
            <> Opt.short 's'
            <> Opt.metavar "TARGET"
            <> Opt.help "Substring to find and highlight"
            )
```

After the creation of a base monad with data-type of commands, let's instantiate settings to Iris:

```haskell
appSettings :: Iris.CliEnvSettings SimpleGrep ()
appSettings = Iris.defaultCliEnvSettings
    { Iris.cliEnvSettingsHeaderDesc = "Iris usage example"
    , Iris.cliEnvSettingsProgDesc = "A simple grep utility"
    , Iris.cliEnvSettingsVersionSettings =
        Just (Iris.defaultVersionSettings Autogen.version)
            { Iris.versionSettingsMkDesc = \v -> "Simple grep utility v" <> v
            }

    , Iris.cliEnvSettingsCmdParser = commandsSettings
    }
```

We describe settings for the app based on `defaultCliEnvSettings`. It helps when we don't need some option to describe, so we can just skip it. Here we can write a CLI-program description, put required tools with a list and then pass commands with the `Parser a` type from `optparse-applicative` to the `cliEnvSettingsCmdParser` field.

Following next, for ensuring about our correctness on defined commands, we would check the `--help` flag's output:

```shell
> cabal exec simple-grep -- --help

Iris usage example

Usage: simple-grep [--version] [--numeric-version] [--no-input]
                   (-f|--filePath PATH) (-s|--substring ARG)

  A simple grep utility

Available options:
  -h,--help                Show this help text
  --version                Show application version
  --numeric-version        Show only numeric application version
  --no-input               Enter the terminal in non-interactive mode
  -f,--filePath PATH       filePath to find and grep file
  -s,--substring ARG       Substring to find and highlight
```

How can we see it, commands were parsed by Iris and showed up in the output! Of course, the `--help` command will work after passing the `appSettings` to the application runner.

## Main monad's do-calculation

Finally, after setting up the configuration, we can describe our computation of CLI:

```haskell
app :: App ()
app = do
    SimpleGrep 
        { filePath, substring } <- Iris.asksCliEnv Iris.cliEnvCmd

    formattedPrinter "Starting grepping ðŸ”¥" Colourista.white
    file <- liftIO $ TIO.readFile filePath

    let fileNameMessage = "file name: " `T.append` (T.pack $ takeFileName filePath)
    let linedFile = T.lines file
    let substringText = T.pack substring

    formattedPrinter fileNameMessage Colourista.cyan

    occurencesPrinter $ substringText `occurencesIn` linedFile
        where
        formattedPrinter :: T.Text -> T.Text -> App ()
        formattedPrinter txt colour =
            Iris.putStderrColouredLn
            (Colourista.formatWith [T.toStrict $ colour, Colourista.bold])
            $ T.toStrict ("\n " `T.append` (txt) `T.append` " ")
```

Our main function and other not-important boilerplate functions for `grep`:

```haskell
main :: IO ()
main = Iris.runCliApp appSettings $ unApp app

occurencesIn :: T.Text ->  [T.Text] -> [(Int, T.Text)]
occurencesIn str = filter (\(_lnNum, txt) -> str `T.isInfixOf` txt) . zip [1 .. ]

occurencesPrinter :: [(Int, T.Text)] -> App ()
occurencesPrinter = mapM_ unpack
    where
        unpack :: (Int, T.Text) -> App ()
        unpack (idx, line) = do
            printIdxWithColon idx
            printLine line

        printIdxWithColon :: Int -> App ()
        printIdxWithColon idx = Iris.putStderrColouredLn
          (Colourista.formatWith [Colourista.yellow, Colourista.bold])
            $ (T.toStrict $ T.pack $ " " `mappend` show idx)
              `mappend`
              (T.toStrict $ T.pack ":")
        printLine :: T.Text -> App ()
        printLine x = Iris.putStdoutColouredLn
            (Colourista.formatWith [T.toStrict $ T.empty]) $ T.toStrict x
```

So, we'd wish to execute all that stuff. Let's do it!

```shell
cabal exec simple-grep -- -f /some/dir/iris/iris.cabal -s iris
```

And output with occurences of "iris":

```
Starting grepping ðŸ”¥ 

file name: iris.cabal 
2:name:                iris
7:    See [README.md](https://github.com/chshersh/iris#iris) for more details.
8:homepage:            https://github.com/chshersh/iris
9:bug-reports:         https://github.com/chshersh/iris/issues
26:  location:            https://github.com/chshersh/iris.git
79:  build-depends:       , iris
119:  autogen-modules:     Paths_iris
120:  other-modules:       Paths_iris
123:     , iris
136:  autogen-modules:     Paths_iris
137:  other-modules:       Paths_iris
150:test-suite iris-test
160:    Paths_iris
164:    , iris
```
